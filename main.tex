\documentclass{../CNTeXBookTemplate/NanCNBook}

%\includeonly{}


\title{\hei\chuhao{Caffe\cite{jia2014caffe}解析}}
\author{nannanmath}

\begin{document}

\maketitle{}
\thispagestyle{empty}

\frontmatter
\pagestyle{plain}
\chapter*{前{\quad}言}
学习Caffe\footnote{http://caffe.berkeleyvision.org/}的设计与实现的细节，从而更好的实现机器学习相关的研究。



% \pagenumbering{roman}
\tableofcontents
\listoffigures
\listoftables


%\pagenumbering{arabic}
\mainmatter
\pagestyle{fancy}

\part{Caffe的依赖与结构}
% Chapter: C/C++编程基础
% Path: include/chp_c_basic/
\include{include/chp_c_basic/chp_c_basic}

% Chapter: CUDA编程基础
% Path: include/chp_cuda_basic/
\include{include/chp_cuda_basic/chp_cuda_basic}

\chapter{Caffe的依赖库}
Caffe代码的实现依赖了大量第三方功能库（特别是使用了多个Google公司的开源库），在“站在巨人的肩膀上”的同时，也为Caffe代码的学习带来一定困难。本章将对这些依赖库的功能和使用做简要介绍。
\section{准标准库Boost}
\subsection{智能指针}\label{deps/boost/pointer}
shared\_ptr智能指针
\section{日志功能glog库}\label{deps/glog}

\section{程序参数处理gflags库}\label{deps/gflags}
fdsfdsfasdfadsf
\section{单元测试gtest库}

\section{结构化protobuf库}

\section{图像处理opencv库}
类型：
cv::Size
cv::Scalar
方法：
cv::merge()
cv::mean()
cv::cvtColor()
cv::resize()
cv::Mat的convertTo()
cv::subtract()
cv::splite()
cv::imread()
cv::Mat(height, width, type, data)
cv::Mat(cv::Size, type, cv::Scalar)
\chapter{Caffe的层次}

\part{Caffe的外部调用}

\chapter{从examples开始} % include/chp_from_examples/
% section 1
% title: 图像分类classification.cpp
\include{include/chp_from_examples/classification_cpp}

\chapter{常用工具tools}
在Caffe代码的tools目录下包含了诸多作为tools的工具软件代码，他们通过对Caffe核心功能的调用实现各种外层的逻辑应用。
\section{计算图像均值compute\_image\_mean.cpp}

\section{图像写入数据库convert\_query.cpp}

\include{include/chp_from_tools/caffe_cpp}
                    



\section{特征提取extract\_feature.cpp}

\section{网络微调finetune\_net.cpp}

\part{Caffe的内部实现}

\chapter{common文件}
在Caffe源代码中有两个文件，名称分别为common.hpp和common.cpp，这里统称为common文件。common文件中包含了一些Caffe中常使用的宏定义、全局初始化函数定义和Caffe类的定义，其中后两者都包含在caffe命名空间中。
\section{常用的宏}
\subsection{宏名转为字符串}
\begin{minted}{c++}
#define STRINGIFY(m) #m
#define AS_STRING(m) STRINGIFY(m)
\end{minted}
在使用时，如果m是一个宏的名字，那么AS\_STRING(m)将得到一个与该宏名一至的字符串。关于这类含有\#字符的宏的详细说明，请参考\ref{c/macro/sharp}。
\subsection{修正gflags的一个问题}
\begin{minted}{c++}
#ifndef GFLAGS_GFLAGS_H_
namespace gflags = google;
#endif  // GFLAGS_GFLAGS_H_
\end{minted}
如代码注释部分所述，对于版本号为2.1的gflags库，其命名空间由原来的google被替换为gflags，因此Caffe通过检查是否存在宏定义GFLAGS_GFLAGS_H_来判断当前gflags的版本，如果为2.1那么就对命名空间名称进行替换。
\subsection{禁止对类对象进行拷贝和赋值操作}
\begin{minted}{c++}
#define INSTANTIATE_CLASS(classname) \
  char gInstantiationGuard##classname; \
  template class classname<float>; \
  template class classname<double>
\end{minted}
在c++编程中，在有些特殊情况下，往往希望禁止类对象的拷贝和赋值操作，最常见的方法是把对应类中的拷贝构造函数和赋值函数定义为私有类型，并且没有任何实现代码。以上定义的宏就是基于这个思路，使用时，只要在类的声明主体中加入该宏，并将参数改为类名即可。

\chapter{底层数据管理SyncedMemory类}
SyncedMemory提供了数据的内存分配、释放以及在主机端（host）与设备端（device）之间的拷贝等功能，是Caffe基本数据存储类型（Blob类）的基础。

\chapter{网络中的数据Blob类}

\chapter{网络定义Layer类}

\chapter{网络管理Net类}

\chapter{网络的运行Slover类}

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%
\cnbibliography{bibtex.bib}


% \appendix
\begin{cnappendix}
\chapter{编译指挥官Makefile}

\end{cnappendix}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
